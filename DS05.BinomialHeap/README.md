# BinomialHeap



**二项堆**

由许多二项树构成，这些树的根构成根表。根表使用链表形式连接起来（方便拓展）。

**二项树**

保证根节点是最小的

多叉树，儿子使用 `std::vector` 

**合并**

合并时，使用两个指针遍历两个根表，

若当前无进位（进位为空或大于较小的指针）：

- 如果当前两指针的树大小不同，则将小的一方加入合并后的树；  1 + 0 + 0 = 1, carry = 0

- 遇到大小相同，调用内置的函数（合并两个`Bk-1` 为一个 `Bk` ） ，并将合并结果存入进位中 1 + 1 + 0 = 0, carry = 1

若当前有进位（进位结果不为空且小等于较小的指针）：

Fact：进位结果的二项树阶数一定大于结果列表中的最大阶数。

- 若进位结果小于当前两指针，

  将进位结果接入结果列表，并清空。0 + 0 + 1 = 1, carry = 0

- 若进位结果等于较小的指针，且两指针不同 1 + 0 + 1 = 0, carry = 1

  较小的指针和进位合并，更新进位。

- 若进位结果等于较小的指针，且两指针相同 1 + 1 + 1 = 1, carry = 1

  进位接入结果列表，两指针合并更新进位。

**取堆顶**

遍历根表，找最小值

**弹出堆顶**

遍历根表找到堆顶，从根表删除该根，并从该二项树删除根。

若此二项树为 `Bk` ，此时会产生 k 个子树，以这 k 个子树构建一个二项堆，与原堆归并

**加入**

用单元素初始化一个二项堆，进行合并。



### 进度

- [x] 合并
- [x] 插入元素
- [x] 堆顶
- [x] 弹出



### 性能

TO DO